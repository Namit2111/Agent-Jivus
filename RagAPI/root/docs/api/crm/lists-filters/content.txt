List filters overview | HubSpot
×
close
We use cookies to improve HubSpot’s site. Some cookies are necessary for our website and services to function properly. Other cookies are optional and help personalize your experience, including advertising and analytics. You can consent to all cookies, decline all optional cookies, or manage optional cookies. Without a selection, our default cookie settings will apply. You can change your preferences at any time. To learn more, check out our
Cookie Policy
.
Accept all
Decline all
Manage cookies
Skip to main content
HubSpot logo
Open site navigation
Getting Started
Overview
What to build
Tools to help you build
Account types
Guides
API & Reference
API Endpoints
CMS Reference
UI Components
(Beta)
Search
Select a language
English
My account
API Guides
Apps
CMS Development
UI Customization
(Beta)
On this page
Filters
Filter evaluation steps
Filter branches
Structure
Filtering on events and associated objects
Filter branch types
OR filter branch
AND filter branch
UNIFIED_EVENTS filter branch
ASSOCIATION filter branch
Filter types
Property filter operations
TIME_POINT and TIME_RANGED examples
Is equal to date
In Last X Number of Days
In Next X Number of Days
Updated or Not Updated in the Last X Days
Is After Date
Is Relative to Today
Is Before or After another property (value or last updated)
Refine by operation
Pruning Refine By operations
Absolute Comparative timestamp
Absolute Ranged timestamp
Relative Comparative timestamp
Relative Ranged timestamp
Coalescing Refine By operations
v1 list filters (legacy)
All property types operations
String operations
Multi-string operations
Number operations
Boolean operations
Enumeration operations
Datetime operations
API Guides
CRM
Lists
List filters overview
List filters
If you select a
SNAPSHOT
or
DYNAMIC
list processing type when creating a list, use filters to determine which records are members of the list.
List filters have conditional logic that is defined by filter branches which have
AND
or
OR
operation types. This is defined by the
filterBranchType
parameter.
Within these branches, there are groups of individual filters that contain logic to assess records to determine if they should be included in the list. These are defined by the
filterType
parameter.
Filter branches can also have nested filter branches.
Filters
There are a variety of different filter types that can be used to build out filters in a list's filter definition. These filters types can be used together in different combinations to construct the logic that is needed for a particular list definition structure.
HubSpot uses
PASS
/
FAIL
logic with filters to determine if a record should be in a list. If a record passes all filters, it will be a member of the list.
Filter evaluation steps
To determine which records pass a list's filters, the following steps occur in order:
Select or fetch the relevant records based on the filter selected. For example, the property values for all records being evaluated for a
property filter.
If applicable, use the
pruningRefineBy
parameter to refine the data to a specific time range (see Refine By Operation section).
Apply the filtering rules against the refined data to determine if the records
PASS
or
FAIL
. For example, if the filter "First Name is equal to "John"" is selected,
PASS
all records that have "John" for their First Name contact property.
If applicable, use the
coalescingRefineBy
parameter to further refine the data to a specific number of occurrences. For example, the filter "contact has filled out a form at least 2 times".
If a
coalescingRefineBy
parameter is present, then
PASS
records that meet the number of occurrences selected.
If no
coalescingRefineBy
parameter is present, then records
PASS
or
FAIL
based on the criteria set in step 3.
Filter branches
A filter branch is a data structure used to build out the conditional logic of a list's definition. Filter branches are defined by a specific type, an operator, a list of filters, and a list of sub-branches.
The filter branch's operator
OR
or
AND
dictate how the filter branch will be evaluated relative to the rest of the branches. The list of filters and sub-filter branches determine which records will be members of a list.
If the filter branch has an
AND
operator, then the record is accepted by the branch if it passes
all
the branch's filters and is accepted by
all
the sub-filter branches.
If the filter branch has an
OR
operator, then the record is accepted by the branch if it passes
any
of the branch's filters or is accepted by
any
of the branch's sub-filter branches.
A record is a member of a list if it is accepted by the root filter branch in the list definition.
Structure
All filter definitions must start with a root-level
OR
filterBranchType
(see
filter branch types
for more details). This root level
OR
filter branch must then have one or more
AND
sub-filter branches.
The root-level
OR
filter branch can be thought of as the parent filter branch while the
AND
sub-filter branches can be thought of as child filter groups. Together, these branches make up the base filter branch structure.
JSON
JSON
More
Copy code snippet
{
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filterBranchType": "AND",
"filters": [
// can have filters here
]
}
// can have more filterBranches here
],
"filterBranchType": "OR",
"filters": []
}
}
1
{
2
"filterBranch"
: {
3
"filterBranches"
: [
4
{
5
"filterBranches"
: [],
6
"filterBranchType"
:
"AND"
,
7
"filters"
: [
8
// can have filters here
9
]
10
}
11
// can have more filterBranches here
12
],
13
"filterBranchType"
:
"OR"
,
14
"filters"
: []
15
}
16
}
For example, to create a list of contacts who have the first name "John" OR
do not
have the last name "Smith", the
POST
body would be:
JSON
JSON
More
Copy code snippet
{
"filterBranch": {
"filterBranchType": "OR",
"filters": [],
"filterBranches": [
{
"filterBranchType": "AND",
"filters": [
{
"filterType": "PROPERTY",
"property": "firstname",
"operation": {
"operationType": "MULTISTRING",
"operator": "IS_EQUAL_TO",
"values": ["John"]
}
}
],
"filterBranches": []
},
{
"filterBranchType": "AND",
"filters": [
{
"filterType": "PROPERTY",
"property": "lastname",
"operation": {
"operationType": "MULTISTRING",
"operator": "IS_NOT_EQUAL_TO",
"values": ["Smith"]
}
}
],
"filterBranches": []
}
]
}
}
xxxxxxxxxx
38
1
{
2
"filterBranch"
: {
3
"filterBranchType"
:
"OR"
,
4
"filters"
: [],
5
"filterBranches"
: [
6
{
7
"filterBranchType"
:
"AND"
,
8
"filters"
: [
9
{
10
"filterType"
:
"PROPERTY"
,
11
"property"
:
"firstname"
,
12
"operation"
: {
13
"operationType"
:
"MULTISTRING"
,
14
"operator"
:
"IS_EQUAL_TO"
,
15
"values"
: [
"John"
]
16
}
17
}
18
],
19
"filterBranches"
: []
20
},
21
{
22
"filterBranchType"
:
"AND"
,
23
"filters"
: [
24
{
25
"filterType"
:
"PROPERTY"
,
26
"property"
:
"lastname"
,
27
"operation"
: {
28
"operationType"
:
"MULTISTRING"
,
29
"operator"
:
"IS_NOT_EQUAL_TO"
,
30
"values"
: [
"Smith"
]
31
}
32
}
33
],
34
"filterBranches"
: []
35
}
36
]
37
}
38
}
In the above example, there is one parent
OR
filterBranchType
parameter with two nested
AND
filterBranchType
parameters. The nested filter branches each have one
filterType
that sets the criteria for the list.
The two
filterType
parameters are nested within
AND
filter branches, rather than directly within an
OR
filter branch. This structure is enforced by HubSpot's API so that the list's filters can be properly rendered in the HubSpot user interface.
In the HubSpot user interface, the above code would look like the image below. Any contacts that meet
either
of the criteria will be a member of the list.
To create a list of contacts who have the first name "John"
and
the last name "Smith":
JSON
JSON
More
Copy code snippet
{
"filterBranch": {
"filterBranchType": "OR",
"filters": [],
"filterBranches": [
{
"filterBranchType": "AND",
"filters": [
{
"filterType": "PROPERTY",
"property": "firstname",
"operation": {
"operationType": "MULTISTRING",
"operator": "IS_EQUAL_TO",
"values": ["John"]
}
},
{
"filterType": "PROPERTY",
"property": "lastname",
"operation": {
"operationType": "MULTISTRING",
"operator": "IS_EQUAL_TO",
"values": ["Smith"]
}
}
],
"filterBranches": []
}
]
}
}
xxxxxxxxxx
32
1
{
2
"filterBranch"
: {
3
"filterBranchType"
:
"OR"
,
4
"filters"
: [],
5
"filterBranches"
: [
6
{
7
"filterBranchType"
:
"AND"
,
8
"filters"
: [
9
{
10
"filterType"
:
"PROPERTY"
,
11
"property"
:
"firstname"
,
12
"operation"
: {
13
"operationType"
:
"MULTISTRING"
,
14
"operator"
:
"IS_EQUAL_TO"
,
15
"values"
: [
"John"
]
16
}
17
},
18
{
19
"filterType"
:
"PROPERTY"
,
20
"property"
:
"lastname"
,
21
"operation"
: {
22
"operationType"
:
"MULTISTRING"
,
23
"operator"
:
"IS_EQUAL_TO"
,
24
"values"
: [
"Smith"
]
25
}
26
}
27
],
28
"filterBranches"
: []
29
}
30
]
31
}
32
}
In the above example, there is one parent
OR
filterBranchType
with one nested
AND
filterBranchType
. The
AND
filterBranchType
has two
filterType
parameters, one for each criteria.
In the HubSpot user interface, the above code would look like the image below. Any contacts that meet the criteria will be a member of the list.
Filtering on events and associated objects
There are two special versions of
AND
filterBranchType
parameters:
UNIFIED_EVENTS
: used to filter on events.
ASSOCIATION
: used to filter on records that are associated with the primary record being evaluated.
These branches should be used within an
AND
filter branch. For example:
JSON
JSON
More
Copy code snippet
{
"filterBranches": [
{
"filterBranches": [
{
"filterBranchType": "UNIFIED_EVENTS",
"filterBranchOperator": "AND",
"filters": [
// must have one or more filters here
]
// additional UNIFIED_EVENTS filter branch details omitted
},
{
"filterBranchType": "ASSOCIATION",
"filterBranchOperator": "AND",
"filters": [
// may have one or more filters here
],
"filterBranches": [
// may have another ASSOCIATION branch here if filtering based on line item properties from a contact list
]
// additional ASSOCIATION filter branch details omitted
}
],
"filterBranchOperator": "AND",
"filterBranchType": "AND",
"filters": [
// can have filters here
]
}
// can have more filterBranches here
],
"filterBranchOperator": "OR",
"filterBranchType": "OR",
"filters": []
}
xxxxxxxxxx
36
1
{
2
"filterBranches"
: [
3
{
4
"filterBranches"
: [
5
{
6
"filterBranchType"
:
"UNIFIED_EVENTS"
,
7
"filterBranchOperator"
:
"AND"
,
8
"filters"
: [
9
// must have one or more filters here
10
]
11
// additional UNIFIED_EVENTS filter branch details omitted
12
},
13
{
14
"filterBranchType"
:
"ASSOCIATION"
,
15
"filterBranchOperator"
:
"AND"
,
16
"filters"
: [
17
// may have one or more filters here
18
],
19
"filterBranches"
: [
20
// may have another ASSOCIATION branch here if filtering based on line item properties from a contact list
21
]
22
// additional ASSOCIATION filter branch details omitted
23
}
24
],
25
"filterBranchOperator"
:
"AND"
,
26
"filterBranchType"
:
"AND"
,
27
"filters"
: [
28
// can have filters here
29
]
30
}
31
// can have more filterBranches here
32
],
33
"filterBranchOperator"
:
"OR"
,
34
"filterBranchType"
:
"OR"
,
35
"filters"
: []
36
}
Filter branch types
Below, review the different
filterBranchType
parameters that can be used to construct your list's filter definition structure.
OR filter branch
Begin your filter definition structure with an
OR
filterBranchType
. It is used to apply
OR
conditional logic against records that are accepted by the nested
AND
filter branches.
OR
filter branches:
Must have one or more
AND
type sub-filter branches.
C
annot
have any filters.
If a record is accepted by
any
of its nested filter branches, an
OR
filter branch will accept the record as well.
JSON
JSON
More
Copy code snippet
{
"filterBranchType": "OR",
"filterBranches": [], // One or more nested AND filter branches
"filters": [] // Zero filters
}
xxxxxxxxxx
5
1
{
2
"filterBranchType"
:
"OR"
,
3
"filterBranches"
: [],
// One or more nested AND filter branches
4
"filters"
: []
// Zero filters
5
}
AND filter branch
The
AND
filterBranchType
is used as a nested filter branch within the parent
OR
filter branch. All filter definitions must have at least one
AND
filter branch for it to be valid. It is used to apply
AND
conditional logic against the records that pass evaluation as defined by its filters and have also been accepted by nested filter branches.
AND
filter branches:
Can have zero or more filters.
Can have zero or more nested
UNIFIED_EVENTS
and/or
ASSOCIATION
filterBranchType
parameters.
An
AND
filter branch accepts a record if the record is accepted by
all
of its nested filter branches and the record passes
all
filters in the filter branch.
JSON
JSON
More
Copy code snippet
{
"filterBranchType": "AND",
"filterBranches": [], // Zero or more nested UNIFIED_EVENTS or ASSOCIATION filter branches
"filters": [] // Zero or more filters
}
xxxxxxxxxx
5
1
{
2
"filterBranchType"
:
"AND"
,
3
"filterBranches"
: [],
// Zero or more nested UNIFIED_EVENTS or ASSOCIATION filter branches
4
"filters"
: []
// Zero or more filters
5
}
UNIFIED_EVENTS filter branch
The
UNIFIED_EVENTS
filterBranchType
can only be used as a nested filter branch within an
AND
filterBranchType
. It is used to determine which records have or have not completed a given unified event.
UNIFIED_EVENTS
type filter branches:
Can have one or more
PROPERTY
type filters.
Cannot have any additional filter branches.
A
UNIFIED_EVENTS
filter branch accepts a record if the record passes
all
filters on the filter branch and the criteria defined by the
UNIFIED_EVENTS
filter branch.
JSON
JSON
More
Copy code snippet
{
"filterBranchType": "UNIFIED_EVENTS",
"filterBranches": [], // Zero filter branches
"filters": [], // Zero or more filters
"eventTypeId": "0-1",
"operator": "HAS_COMPLETED"
}
xxxxxxxxxx
7
1
{
2
"filterBranchType"
:
"UNIFIED_EVENTS"
,
3
"filterBranches"
: [],
// Zero filter branches
4
"filters"
: [],
// Zero or more filters
5
"eventTypeId"
:
"0-1"
,
6
"operator"
:
"HAS_COMPLETED"
7
}
Parameter
Accepted Values
operator
HAS_COMPLETED
,
HAS_NOT_COMPLETED
ASSOCIATION filter branch
The
ASSOCIATION
filterBranchType
can only be used as a nested filter branch within an
AND
filterBranchType
. It is used to filter on records which are associated with the primary record being evaluated.
ASSOCIATION
filter branches:
Must have one or more filters.
Cannot have any additional nested filter branches.
An
ASSOCIATION
filter branch accepts a record if it is accepted by
all
of its nested filter branches and if the record
PASSES
all filters of the filter branch.
You can only have additional
filterBranches
in the case of a
CONTACT
to
LINE_ITEM
association.
JSON
JSON
More
Copy code snippet
{
"filterBranchType": "ASSOCIATION",
"filterBranches": [], // Zero or one nested ASSOCIATION filter branches
"filters": [], // Zero or more filters
"objectTypeId": "0-1",
"operator": "IN_LIST",
"associationTypeId": 280,
"associationCategory": "HUBSPOT_DEFINED"
}
xxxxxxxxxx
9
1
{
2
"filterBranchType"
:
"ASSOCIATION"
,
3
"filterBranches"
: [],
// Zero or one nested ASSOCIATION filter branches
4
"filters"
: [],
// Zero or more filters
5
"objectTypeId"
:
"0-1"
,
6
"operator"
:
"IN_LIST"
,
7
"associationTypeId"
:
280
,
8
"associationCategory"
:
"HUBSPOT_DEFINED"
9
}
Parameter
Accepted Values
operator
IN_LIST
associationCategory
HUBSPOT_DEFINED
,
USER_DEFINED
,
INTEGRATOR_DEFINED
Filter types
Review the table below for the different types of filters that can be used. The
filterType
parameter is used to define the filter within the
filterBranch
.
For more information, see the
list filters reference page
.
Parameter
Description
ADS_TIME
Evaluates whether a contact has seen any ads in the timeframe defined by the
pruningRefineBy
parameter.
ADS_SEARCH
Evaluates whether a contact has performed the ad interactions as defined by the filter.
CTA
Evaluates whether a contact has or has not interacted with a specific call-to-action as defined by the filter.
EMAIL_EVENT
Evaluate the opt-in status of a contact for specific email subscriptions as defined by the filter.
EVENT
Evaluates whether a contact has or does not have a specific event as defined by the filter.
FORM_SUBMISSION
Evaluates whether a contact has or has not filled out a specific form or any form as defined by the filter.
FORM_SUBMISSION_ON_PAGE
Evaluates whether a contact has or has not filled out a specific or any form on a specific page as defined by the filter.
IN_LIST
Evaluates whether a record is or is not a member of a specific list, import, or workflow as defined by the filter.
PAGE_VIEW
Evaluates whether a contact has or has not viewed a specific page as defined by the filter.
PRIVACY
Evaluates whether a contact does or does not have privacy consent for a specific privacy type as defined by the filter.
PROPERTY
Evaluates whether a record’s property value satisfies the property filter operation as defined by the filter. See the
property filter operations
section for more details.
SURVEY_MONKEY
Evaluates whether a contact has or has not responded to a specific Survey Monkey survey as defined by the filter.
SURVEY_MONKEY_VALUE
Evaluates whether a contact has or has not responded to a specific Survey Monkey survey’s question with a specified value as defined by the filter.
WEBINAR
Evaluates whether a contact has or has not registered or attended any webinars or a specific webinar as defined by the filter.
INTEGRATION_EVENT
Integration event filters can be used to filter specific contacts based on whether or not they have interacted with integration events that have properties as specified by the filter lines.
Property filter operations
When filtering for records with the
PROPERTY
,
INTEGRATION_EVENT
, or
SURVEY_MONKEY_VALUE
filter type, you'll include an
operation
object to define the parameters of the filter. This object can contain the following fields:
operationType
: the type of operator that you're filtering by (e.g.,
NUMBER
). Each type of property supports a set of operation types, and each operation type supports a set of operators, which you'll define with the
operator
field. (e.g.,
IS
and
IS_NOT
).
operator
: the operator that will be applied to
operationType
(e.g.,
IS
and
IS_NOT
). Each property type supports a set of operators. Learn more about property types and their supporter operators in the table below.
value
/
values
: the value or values to filter by. Some operators can accept one value, while others can accept multiple values in an array.
includeObjectsWithNoValueSet
: defines how the operation should treat records that do not have a value set for the defined property.
If
true
, a record without a value for the evaluated property will be
accepted
.
If
false
(default), a record without a value for the evaluated property will be
rejected
.
For example, the filter below would filter for contacts with a
firstname
property value of
John
.
Copy code snippet
"filters": [
{
"filterType": "PROPERTY",
"property": "firstname",
"operation": {
"operationType": "MULTISTRING",
"operator": "IS_EQUAL_TO",
"values": ["John"]
}
}
]
xxxxxxxxxx
11
1
"filters"
: [
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"firstname"
,
5
"operation"
: {
6
"operationType"
:
"MULTISTRING"
,
7
"operator"
:
"IS_EQUAL_TO"
,
8
"values"
: [
"John"
]
9
}
10
}
11
]
The table below gives an overview of the available operation types. For more information, along with example code, check out the
property operation definitions reference
.
OperationType
Supported operators
Description
ALL_PROPERTY
String
Used to determine whether a property value is known or is unknown as defined by the property operation.
BOOL
String
Used to determine whether a current (or historical) boolean property value is or is not (or has or has not) equaled a specific value.
ENUMERATION
String
Used to determine whether an enumeration/multi-select property value is any of, is none of, is exactly, is not exactly, contains all of, does not contain all of, has ever been any of, has never been any of, has ever been exactly, has never been exactly, has ever contained all, or has never contained all of a given set of values as defined by the property operation.
MULTISTRING
String
Used to determine whether a string property value is equal to, is not equal to, contains, does not contain, starts with, or ends with any of a given set of values as defined by the property operation.
NUMBER
String
Used to determine whether a current (or historical) number property value is or is not (or has or has not) equaled a specific value as defined by the property operation.
STRING
String
Used to determine whether a current (or historical) string property value is or is not (or has or has not) equaled a specific value as defined by the property operation.
TIME_POINT
String
Used to determine if a property has been updated before or after a specific time. That time can be specified as a specific date or relative to the current day. This operation also allows the comparison of two properties or their last updated time.
TIME_RANGED
String
Used to determine if a property has been updated between or outside of two specific times. These times can be specified as a specific date or relative to the current day.
TIME_POINT and TIME_RANGED examples
Below, review some examples when using the
TIME_POINT
and
TIME_RANGED
parameter. These parameters can be used in both time-referenced and property-referenced requests. For more information, see the
Is equal to date
The request below filters for
Last activity date is equal to 03/11/2024 (EDT)
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Date Equal",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_BETWEEN",
"includeObjectsWithNoValueSet": false,
"lowerBoundEndpointBehavior": "INCLUSIVE",
"upperBoundEndpointBehavior": "INCLUSIVE",
"propertyParser": "VALUE",
"lowerBoundTimePoint": {
"timeType": "DATE",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"year": 2024,
"month": 3,
"day": 11,
"hour": 0,
"minute": 0,
"second": 0,
"millisecond": 0
},
"upperBoundTimePoint": {
"timeType": "DATE",
"timezoneSource": "CUSTOM",
"zoneId": "US/Eastern",
"year": 2024,
"month": 3,
"day": 11,
"hour": 23,
"minute": 59,
"second": 59,
"millisecond": 999
},
"type": "TIME_RANGED",
"operationType": "TIME_RANGED"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
xxxxxxxxxx
55
1
{
2
"name"
:
"Sample Date Equal"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_BETWEEN"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"lowerBoundEndpointBehavior"
:
"INCLUSIVE"
,
16
"upperBoundEndpointBehavior"
:
"INCLUSIVE"
,
17
"propertyParser"
:
"VALUE"
,
18
"lowerBoundTimePoint"
: {
19
"timeType"
:
"DATE"
,
20
"timezoneSource"
:
"CUSTOM"
,
21
"zoneId"
:
"America/New_York"
,
22
"year"
:
2024
,
23
"month"
:
3
,
24
"day"
:
11
,
25
"hour"
:
0
,
26
"minute"
:
0
,
27
"second"
:
0
,
28
"millisecond"
:
0
29
},
30
"upperBoundTimePoint"
: {
31
"timeType"
:
"DATE"
,
32
"timezoneSource"
:
"CUSTOM"
,
33
"zoneId"
:
"US/Eastern"
,
34
"year"
:
2024
,
35
"month"
:
3
,
36
"day"
:
11
,
37
"hour"
:
23
,
38
"minute"
:
59
,
39
"second"
:
59
,
40
"millisecond"
:
999
41
},
42
"type"
:
"TIME_RANGED"
,
43
"operationType"
:
"TIME_RANGED"
44
},
45
"filterType"
:
"PROPERTY"
46
}
47
],
48
"filterBranchType"
:
"AND"
,
49
"filterBranchOperator"
:
"AND"
50
}
51
],
52
"filters"
: [],
53
"filterBranchOperator"
:
"OR"
,
54
"filterBranchType"
:
"OR"
55
}
In Last X Number of Days
The example below filters for
Last activity date is less than 3 days ago
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Date Last 3 days",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_BETWEEN",
"includeObjectsWithNoValueSet": false,
"lowerBoundEndpointBehavior": "INCLUSIVE",
"upperBoundEndpointBehavior": "INCLUSIVE",
"propertyParser": "VALUE",
"lowerBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "US/Eastern",
"indexReference": {
"referenceType": "TODAY"
},
"offset": {
"days": -3
}
},
"upperBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"indexReference": {
"referenceType": "NOW"
}
},
"type": "TIME_RANGED",
"operationType": "TIME_RANGED"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
}
xxxxxxxxxx
51
1
{
2
"name"
:
"Sample Date Last 3 days"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_BETWEEN"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"lowerBoundEndpointBehavior"
:
"INCLUSIVE"
,
16
"upperBoundEndpointBehavior"
:
"INCLUSIVE"
,
17
"propertyParser"
:
"VALUE"
,
18
"lowerBoundTimePoint"
: {
19
"timeType"
:
"INDEXED"
,
20
"timezoneSource"
:
"CUSTOM"
,
21
"zoneId"
:
"US/Eastern"
,
22
"indexReference"
: {
23
"referenceType"
:
"TODAY"
24
},
25
"offset"
: {
26
"days"
:
-
3
27
}
28
},
29
"upperBoundTimePoint"
: {
30
"timeType"
:
"INDEXED"
,
31
"timezoneSource"
:
"CUSTOM"
,
32
"zoneId"
:
"America/New_York"
,
33
"indexReference"
: {
34
"referenceType"
:
"NOW"
35
}
36
},
37
"type"
:
"TIME_RANGED"
,
38
"operationType"
:
"TIME_RANGED"
39
},
40
"filterType"
:
"PROPERTY"
41
}
42
],
43
"filterBranchType"
:
"AND"
,
44
"filterBranchOperator"
:
"AND"
45
}
46
],
47
"filters"
: [],
48
"filterBranchOperator"
:
"OR"
,
49
"filterBranchType"
:
"OR"
50
}
51
}
In Next X Number of Days
The example below filters for
Last activity date is less than 5 days from now
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Date Next 5 Days",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_BETWEEN",
"includeObjectsWithNoValueSet": false,
"lowerBoundEndpointBehavior": "INCLUSIVE",
"upperBoundEndpointBehavior": "INCLUSIVE",
"propertyParser": "VALUE",
"lowerBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "US/Eastern",
"indexReference": {
"referenceType": "NOW"
}
},
"upperBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "US/Eastern",
"indexReference": {
"referenceType": "TODAY"
},
"offset": {
"days": 5
}
},
"type": "TIME_RANGED",
"operationType": "TIME_RANGED"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
}
xxxxxxxxxx
51
1
{
2
"name"
:
"Sample Date Next 5 Days"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_BETWEEN"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"lowerBoundEndpointBehavior"
:
"INCLUSIVE"
,
16
"upperBoundEndpointBehavior"
:
"INCLUSIVE"
,
17
"propertyParser"
:
"VALUE"
,
18
"lowerBoundTimePoint"
: {
19
"timeType"
:
"INDEXED"
,
20
"timezoneSource"
:
"CUSTOM"
,
21
"zoneId"
:
"US/Eastern"
,
22
"indexReference"
: {
23
"referenceType"
:
"NOW"
24
}
25
},
26
"upperBoundTimePoint"
: {
27
"timeType"
:
"INDEXED"
,
28
"timezoneSource"
:
"CUSTOM"
,
29
"zoneId"
:
"US/Eastern"
,
30
"indexReference"
: {
31
"referenceType"
:
"TODAY"
32
},
33
"offset"
: {
34
"days"
:
5
35
}
36
},
37
"type"
:
"TIME_RANGED"
,
38
"operationType"
:
"TIME_RANGED"
39
},
40
"filterType"
:
"PROPERTY"
41
}
42
],
43
"filterBranchType"
:
"AND"
,
44
"filterBranchOperator"
:
"AND"
45
}
46
],
47
"filters"
: [],
48
"filterBranchOperator"
:
"OR"
,
49
"filterBranchType"
:
"OR"
50
}
51
}
Updated or Not Updated in the Last X Days
The example below filters for
Last activity date updated in last 7 days
.
To filter for
Last activity date
not updated in last
7 days
, change the
operator
parameter to
IS_NOT_BETWEEN
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Date Updated Last 7 Days",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_BETWEEN",
"includeObjectsWithNoValueSet": false,
"lowerBoundEndpointBehavior": "INCLUSIVE",
"upperBoundEndpointBehavior": "INCLUSIVE",
"propertyParser": "UPDATED_AT",
"lowerBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"indexReference": {
"referenceType": "TODAY"
},
"offset": {
"days": -7
}
},
"upperBoundTimePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"indexReference": {
"referenceType": "NOW"
}
},
"type": "TIME_RANGED",
"operationType": "TIME_RANGED"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
}
xxxxxxxxxx
51
1
{
2
"name"
:
"Sample Date Updated Last 7 Days"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_BETWEEN"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"lowerBoundEndpointBehavior"
:
"INCLUSIVE"
,
16
"upperBoundEndpointBehavior"
:
"INCLUSIVE"
,
17
"propertyParser"
:
"UPDATED_AT"
,
18
"lowerBoundTimePoint"
: {
19
"timeType"
:
"INDEXED"
,
20
"timezoneSource"
:
"CUSTOM"
,
21
"zoneId"
:
"America/New_York"
,
22
"indexReference"
: {
23
"referenceType"
:
"TODAY"
24
},
25
"offset"
: {
26
"days"
:
-
7
27
}
28
},
29
"upperBoundTimePoint"
: {
30
"timeType"
:
"INDEXED"
,
31
"timezoneSource"
:
"CUSTOM"
,
32
"zoneId"
:
"America/New_York"
,
33
"indexReference"
: {
34
"referenceType"
:
"NOW"
35
}
36
},
37
"type"
:
"TIME_RANGED"
,
38
"operationType"
:
"TIME_RANGED"
39
},
40
"filterType"
:
"PROPERTY"
41
}
42
],
43
"filterBranchType"
:
"AND"
,
44
"filterBranchOperator"
:
"AND"
45
}
46
],
47
"filters"
: [],
48
"filterBranchOperator"
:
"OR"
,
49
"filterBranchType"
:
"OR"
50
}
51
}
Is After Date
The example below filters for
Last activity date is
after
03/04/2024 (EST)
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Date After",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_AFTER",
"includeObjectsWithNoValueSet": false,
"timePoint": {
"timeType": "DATE",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"year": 2024,
"month": 3,
"day": 4,
"hour": 23,
"minute": 59,
"second": 59,
"millisecond": 999
},
"endpointBehavior": "EXCLUSIVE",
"propertyParser": "VALUE",
"type": "TIME_POINT",
"operationType": "TIME_POINT"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
}
xxxxxxxxxx
43
1
{
2
"name"
:
"Sample Date After"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_AFTER"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"timePoint"
: {
16
"timeType"
:
"DATE"
,
17
"timezoneSource"
:
"CUSTOM"
,
18
"zoneId"
:
"America/New_York"
,
19
"year"
:
2024
,
20
"month"
:
3
,
21
"day"
:
4
,
22
"hour"
:
23
,
23
"minute"
:
59
,
24
"second"
:
59
,
25
"millisecond"
:
999
26
},
27
"endpointBehavior"
:
"EXCLUSIVE"
,
28
"propertyParser"
:
"VALUE"
,
29
"type"
:
"TIME_POINT"
,
30
"operationType"
:
"TIME_POINT"
31
},
32
"filterType"
:
"PROPERTY"
33
}
34
],
35
"filterBranchType"
:
"AND"
,
36
"filterBranchOperator"
:
"AND"
37
}
38
],
39
"filters"
: [],
40
"filterBranchOperator"
:
"OR"
,
41
"filterBranchType"
:
"OR"
42
}
43
}
Is Relative to Today
The example below can either represent
Last activity date is more than x days from
now
or
Last activity date is more than x days
ago
.
To filter for the latter, set the value for the
offset
parameter to
<=0
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Days From Now",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_AFTER",
"includeObjectsWithNoValueSet": false,
"timePoint": {
"timeType": "INDEXED",
"timezoneSource": "CUSTOM",
"zoneId": "America/New_York",
"indexReference": {
"referenceType": "TODAY"
},
"offset": {
"days": 2
}
},
"endpointBehavior": "EXCLUSIVE",
"propertyParser": "VALUE",
"type": "TIME_POINT",
"operationType": "TIME_POINT"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchOperator": "OR",
"filterBranchType": "OR"
}
}
xxxxxxxxxx
42
1
{
2
"name"
:
"Sample Days From Now"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_AFTER"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"timePoint"
: {
16
"timeType"
:
"INDEXED"
,
17
"timezoneSource"
:
"CUSTOM"
,
18
"zoneId"
:
"America/New_York"
,
19
"indexReference"
: {
20
"referenceType"
:
"TODAY"
21
},
22
"offset"
: {
23
"days"
:
2
24
}
25
},
26
"endpointBehavior"
:
"EXCLUSIVE"
,
27
"propertyParser"
:
"VALUE"
,
28
"type"
:
"TIME_POINT"
,
29
"operationType"
:
"TIME_POINT"
30
},
31
"filterType"
:
"PROPERTY"
32
}
33
],
34
"filterBranchType"
:
"AND"
,
35
"filterBranchOperator"
:
"AND"
36
}
37
],
38
"filters"
: [],
39
"filterBranchOperator"
:
"OR"
,
40
"filterBranchType"
:
"OR"
41
}
42
}
Is Before or After another property (value or last updated)
The example below compares the values where
Last activity date is
before
Latest Open Lead Date
.
To filter for
Last activity date is
after
Latest Open Lead Date
: set the
operator
value to
IS_AFTER
.
To filter for when the Latest Open Lead Date was updated: set the
referenceType
value to
UPDATED_AT
.
JSON
JSON
More
Copy code snippet
{
"name": "Sample Property Before",
"objectTypeId": "0-1",
"processingType": "DYNAMIC",
"filterBranch": {
"filterBranches": [
{
"filterBranches": [],
"filters": [
{
"property": "notes_last_updated",
"operation": {
"operator": "IS_BEFORE",
"includeObjectsWithNoValueSet": false,
"timePoint": {
"timeType": "PROPERTY_REFERENCED",
"timezoneSource": "CUSTOM",
"zoneId": "US/Eastern",
"property": "hs_latest_open_lead_date",
"referenceType": "VALUE"
},
"endpointBehavior": "EXCLUSIVE",
"propertyParser": "VALUE",
"type": "TIME_POINT",
"operationType": "TIME_POINT"
},
"filterType": "PROPERTY"
}
],
"filterBranchType": "AND",
"filterBranchOperator": "AND"
}
],
"filters": [],
"filterBranchType": "OR",
"filterBranchOperator": "OR"
}
}
xxxxxxxxxx
38
1
{
2
"name"
:
"Sample Property Before"
,
3
"objectTypeId"
:
"0-1"
,
4
"processingType"
:
"DYNAMIC"
,
5
"filterBranch"
: {
6
"filterBranches"
: [
7
{
8
"filterBranches"
: [],
9
"filters"
: [
10
{
11
"property"
:
"notes_last_updated"
,
12
"operation"
: {
13
"operator"
:
"IS_BEFORE"
,
14
"includeObjectsWithNoValueSet"
:
false
,
15
"timePoint"
: {
16
"timeType"
:
"PROPERTY_REFERENCED"
,
17
"timezoneSource"
:
"CUSTOM"
,
18
"zoneId"
:
"US/Eastern"
,
19
"property"
:
"hs_latest_open_lead_date"
,
20
"referenceType"
:
"VALUE"
21
},
22
"endpointBehavior"
:
"EXCLUSIVE"
,
23
"propertyParser"
:
"VALUE"
,
24
"type"
:
"TIME_POINT"
,
25
"operationType"
:
"TIME_POINT"
26
},
27
"filterType"
:
"PROPERTY"
28
}
29
],
30
"filterBranchType"
:
"AND"
,
31
"filterBranchOperator"
:
"AND"
32
}
33
],
34
"filters"
: [],
35
"filterBranchType"
:
"OR"
,
36
"filterBranchOperator"
:
"OR"
37
}
38
}
Refine by operation
There are two types of refine by operations that can be used in certain filters:
pruningRefineBy
: refine the data set to a particular timeframe.
coalescingRefineBy
: determines whether the record
PASSES
the filter the number of times defined.
Filters only support up to one refine by operation at a time, even if some filters allow for both a coalescing and pruning refine by operation to be passed in. This is enforced by HubSpot's API.
Pruning Refine By operations
Pruning refine by operations are used to narrow down the dataset that will be used for filter evaluation by refining the dataset to a particular timeframe. Pruning refine by operations are classified into two types: relative and absolute.
Relative
: narrow the dataset down based on a time offset of a number of days or weeks in the past or in the future.
Absolute
: narrow the dataset down based on the data being before or after a specific timestamp
For both relative and absolute refine by operations, there are ranged and comparative derivatives.
Absolute Comparative timestamp
Used to narrow the relevant dataset down based on whether the timestamp of the data being evaluated is before or after a specific timestamp as defined by the refine by operation.
JSON
JSON
More
Copy code snippet
{
"type": "ABSOLUTE_COMPARATIVE",
"comparison": "BEFORE",
"timestamp": 1698915170126
}
xxxxxxxxxx
5
1
{
2
"type"
:
"ABSOLUTE_COMPARATIVE"
,
3
"comparison"
:
"BEFORE"
,
4
"timestamp"
:
1698915170126
5
}
Parameter
Description
comparison
Whether the data's timestamp is before or after the defined
timestamp
. Values include:
BEFORE
,
AFTER
Absolute Ranged timestamp
Used to narrow the relevant dataset down based on whether the timestamp of the data being evaluated is between or is not between an upper and lower bound timestamp as defined by the refine by operation.
JSON
JSON
More
Copy code snippet
{
"type": "ABSOLUTE_RANGED",
"rangeType": "BETWEEN",
"lowerTimestamp": 1698915170126,
"upperTimestamp": 1682406908449
}
xxxxxxxxxx
6
1
{
2
"type"
:
"ABSOLUTE_RANGED"
,
3
"rangeType"
:
"BETWEEN"
,
4
"lowerTimestamp"
:
1698915170126
,
5
"upperTimestamp"
:
1682406908449
6
}
Parameter
Description
rangeType
Whether the data's timestamp is between or not between the defined
lowerTimestamp
and
upperTimestamp
. Values include:
BETWEEN
,
NOT_BETWEEN
Relative Comparative timestamp
Used to narrow the relevant dataset down based on whether the timestamp of the data being evaluated is before or after a certain number of days or weeks in the past or future relative to the current timestamp as defined by the refine by operation.
JSON
JSON
More
Copy code snippet
{
"type": "RELATIVE_COMPARATIVE",
"comparison": "BEFORE",
"timeOffset": [
"offsetDirection": "PAST",
"timeUnit": "DAYS",
"amount": 4
],
}
xxxxxxxxxx
9
1
{
2
"type"
:
"RELATIVE_COMPARATIVE"
,
3
"comparison"
:
"BEFORE"
,
4
"timeOffset"
: [
5
"offsetDirection"
:
"PAST"
,
6
"timeUnit"
:
"DAYS"
,
7
"amount"
:
4
8
],
9
}
Parameter
Description
comparison
Whether the data's timestamp is before or after the defined
timeOffset
values. Values include:
BEFORE
,
AFTER
offsetDirection
Values include:
PAST
,
FUTURE
timeUnit
Values include:
DAYS
,
WEEKS
amount
A number value.
Relative Ranged timestamp
Used to narrow the relevant dataset down based on whether the timestamp of the data being evaluated is between or is not between an upper and lower bound time offset relative to the current timestamp. The time offsets are a certain number of days or weeks in the past or the future as defined by the refine by operation.
JSON
JSON
More
Copy code snippet
{
"type": "RELATIVE_RANGED",
"rangeType": "BETWEEN",
"timeOffset": [
"offsetDirection": "PAST",
"timeUnit": "DAYS",
"amount": 4
],
}
xxxxxxxxxx
9
1
{
2
"type"
:
"RELATIVE_RANGED"
,
3
"rangeType"
:
"BETWEEN"
,
4
"timeOffset"
: [
5
"offsetDirection"
:
"PAST"
,
6
"timeUnit"
:
"DAYS"
,
7
"amount"
:
4
8
],
9
}
Parameter
Description
rangeType
Whether the data's timestamp is between or not between the defined
timeOffset
values. Values include:
BETWEEN
,
NOT_BETWEEN
offsetDirection
Values include:
PAST
,
FUTURE
timeUnit
Values include:
DAYS
,
WEEKS
amount
A number value.
Coalescing Refine By operations
Coalescing refine by operations are used once the filter criteria has been applied to the relevant dataset. The only coalescing refine by operation supported by the Lists API is a “number of occurrences” operation that determines whether an object in the dataset
PASSED
the filter evaluation at least a minimum number of times and less than a maximum number of times.
JSON
JSON
More
Copy code snippet
{
"type": "NUM_OCCURRENCES",
"minOccurrences": 1, // Optional
"maxOccurrences": 4 // Optional
}
xxxxxxxxxx
5
1
{
2
"type"
:
"NUM_OCCURRENCES"
,
3
"minOccurrences"
:
1
,
// Optional
4
"maxOccurrences"
:
4
// Optional
5
}
Parameter
Description
NUM_OCCURRENCES
Used to determine whether an object in the relevant dataset PASSED the filter evaluation at least a minimum number of times (or zero times if a minimum is not provided) and at most a maximum number of times (or any number of times if a maximum is not provided) as defined by the refine by operation.
v1 list filters (legacy)
If you're using the v1 lists API, the way that you filter lists is similar to the v3 API. However, there are minor differences in syntax and options available. Learn more about v1 list filters below.
Starting May 30, 2025, the
legacy v1 Lists API
will be sunset. If you were previously using the v1 Lists API, review the
guide below
to transition to the v3 API.
Filter branches are AND / OR clauses that contain sets of filters and other filter branches. The only supported
filterType
for v1 lists is
PROPERTY
. Below,
Copy code snippet
"filterBranch": {
"filterBranchType": "AND",
"filters": [
{
"property": "amount",
"operation": {
"value": 50,
"operator": "IS_GREATER_THAN",
"propertyType": "number"
},
"filterType": "PROPERTY"
}
],
"filterBranches": []
}
xxxxxxxxxx
15
1
"filterBranch"
: {
2
"filterBranchType"
:
"AND"
,
3
"filters"
: [
4
{
5
"property"
:
"amount"
,
6
"operation"
: {
7
"value"
:
50
,
8
"operator"
:
"IS_GREATER_THAN"
,
9
"propertyType"
:
"number"
10
},
11
"filterType"
:
"PROPERTY"
12
}
13
],
14
"filterBranches"
: []
15
}
All property types operations
For any property, filters for whether the property value is known or unknown. Available operators are:
IS_KNOWN
and
IS_NOT_KNOWN
.
Copy code snippet
// alltypes filter
{
"filterType": "PROPERTY",
"property": "any_property",
"operation": {
"propertyType": "alltypes",
"operator": "IS_KNOWN"
}
}
xxxxxxxxxx
9
1
// alltypes filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"any_property"
,
5
"operation"
: {
6
"propertyType"
:
"alltypes"
,
7
"operator"
:
"IS_KNOWN"
8
}
9
}
String operations
Operations for string type properties.
Available operators are:
IS_EQUAL_TO
,
IS_NOT_EQUAL_TO
,
CONTAINS
,
DOES_NOT_CONTAIN
,
STARTS_WITH
,
ENDS_WITH
,
HAS_EVER_BEEN_EQUAL_TO
,
HAS_NEVER_BEEN_EQUAL_TO
,
HAS_EVER_CONTAINED
,
HAS_NEVER_CONTAINED
.
Copy code snippet
// string property filter
{
"filterType": "PROPERTY",
"property": "string_property_name",
"operation": {
"propertyType": "string",
"operator": "CONTAINS",
"value": "def"
}
}
xxxxxxxxxx
10
1
// string property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"string_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"string"
,
7
"operator"
:
"CONTAINS"
,
8
"value"
:
"def"
9
}
10
}
Multi-string operations
Operations for multiple string values.
Available operators are:
IS_EQUAL_TO
,
IS_NOT_EQUAL_TO
,
CONTAINS
,
DOES_NOT_CONTAIN
,
STARTS_WITH
,
ENDS_WITH
.
Copy code snippet
// multi-string property filter
{
"filterType": "PROPERTY",
"property": "string_property_name",
"operation": {
"propertyType": "multistring",
"operator": "CONTAINS",
"values": ["def", "abc", "123"]
}
}
xxxxxxxxxx
10
1
// multi-string property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"string_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"multistring"
,
7
"operator"
:
"CONTAINS"
,
8
"values"
: [
"def"
,
"abc"
,
"123"
]
9
}
10
}
Number operations
Operations for number type properties.
Available operators are:
IS_EQUAL_TO
,
IS_NOT_EQUAL_TO
,
CONTAINS
,
DOES_NOT_CONTAIN
,
STARTS_WITH
,
ENDS_WITH
,
HAS_EVER_BEEN_EQUAL_TO
,
HAS_NEVER_BEEN_EQUAL_TO
,
IS_BETWEEN
,
IS_NOT_BETWEEN
.
Copy code snippet
// number property filter
{
"filterType": "PROPERTY",
"property": "number_property_name",
"operation": {
"propertyType": "number",
"operator": "IS_GREATER_THAN",
"value": 100
}
}
xxxxxxxxxx
10
1
// number property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"number_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"number"
,
7
"operator"
:
"IS_GREATER_THAN"
,
8
"value"
:
100
9
}
10
}
To filter for ranges, include a
lowerBound
and
upperBound
.
Copy code snippet
// number property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "number-ranged",
"operator": "IS_BETWEEN",
"lowerBound": 0,
"upperBound": 10
}
}
xxxxxxxxxx
11
1
// number property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"number-ranged"
,
7
"operator"
:
"IS_BETWEEN"
,
8
"lowerBound"
:
0
,
9
"upperBound"
:
10
10
}
11
}
Boolean operations
Operations for boolean type properties. Can only filter for a
value
of
true
or
false
.
Available operators are:
IS_EQUAL_TO
,
IS_NOT_EQUAL_TO
,
HAS_EVER_BEEN_EQUAL_TO, HAS_NEVER_BEEN_EQUAL_TO
.
Copy code snippet
// boolean property filter
{
"filterType": "PROPERTY",
"property": "boolean_property_name",
"operation": {
"propertyType": "bool",
"operator": "IS_EQUAL_TO",
"value": true
}
}
xxxxxxxxxx
10
1
// boolean property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"boolean_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"bool"
,
7
"operator"
:
"IS_EQUAL_TO"
,
8
"value"
:
true
9
}
10
}
Enumeration operations
Operations for enumeration type properties.
Available operators are:
IS_EQUAL_TO
,
IS_NOT_EQUAL_TO
,
HAS_EVER_BEEN_ANY_OF, HAS_NEVER_BEEN_ANY_OF
.
Copy code snippet
// enumeration property filter
{
"filterType": "PROPERTY",
"property": "enumeration_property_name",
"operation": {
"propertyType": "enumeration",
"operator": "IS_ANY_OF",
"values": ["abc", "def", "xyz"]
}
}
xxxxxxxxxx
10
1
// enumeration property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"enumeration_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"enumeration"
,
7
"operator"
:
"IS_ANY_OF"
,
8
"values"
: [
"abc"
,
"def"
,
"xyz"
]
9
}
10
}
Datetime operations
There are five different operation types for datetime properties, as set by the
propertyType
field:
datetime
: compares the property value to a specific datetime stamp. Available operators are:
IS_EQUAL_TO
,
IS_BEFORE_DATE
(millisecond of day's start),
IS_AFTER_DATE
(last millisecond of day's end).
Copy code snippet
// datetime property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "datetime",
"operator": "IS_EQUAL_TO",
"timestamp": 1504703360618
}
}
xxxxxxxxxx
10
1
// datetime property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"datetime"
,
7
"operator"
:
"IS_EQUAL_TO"
,
8
"timestamp"
:
1504703360618
9
}
10
}
datetime-comparative
: compares the property value to another other datetime property on the contact record. Available operators are:
IS_BEFORE
,
IS_AFTER
.
Copy code snippet
// datetime comparative property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "datetime-comparative",
"operator": "IS_AFTER",
"comparisonPropertyName": "other_datetime_property"
}
}
xxxxxxxxxx
10
1
// datetime comparative property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"datetime-comparative"
,
7
"operator"
:
"IS_AFTER"
,
8
"comparisonPropertyName"
:
"other_datetime_property"
9
}
10
}
datetime-ranged
: compares the property value to a specific timestamp range. Available operators are:
IS_BETWEEN
,
IS_NOT_BETWEEN
.
Copy code snippet
// datetime range property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "datetime-ranged",
"operator": "IS_BETWEEN",
"lowerBoundTimestamp": 1,
"upperBoundTimestamp": 2
}
}
xxxxxxxxxx
11
1
// datetime range property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"datetime-ranged"
,
7
"operator"
:
"IS_BETWEEN"
,
8
"lowerBoundTimestamp"
:
1
,
9
"upperBoundTimestamp"
:
2
10
}
11
}
datetime-rolling
: compares the property value to a rolling number of days. Available operators are:
IS_LESS_THAN_X_DAYS_AGO
,
IS_MORE_THAN_X_DAYS_AGO, IS_LESS_THAN_X_DAYS_FROM_NOW
,
IS_MORE_THAN_X_DAYS_FROM_NOW
.
Copy code snippet
// datetime rolling property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "datetime-rolling",
"operator": "IS_LESS_THAN_X_DAYS_AGO"
"numberOfDays": 5,
}
}
xxxxxxxxxx
10
1
// datetime rolling property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"datetime-rolling"
,
7
"operator"
:
"IS_LESS_THAN_X_DAYS_AGO"
8
"numberOfDays"
:
5
,
9
}
10
}
rolling-property-updated
: compares the last time the property was updated to a rolling number of days. Available operators are:
UPDATED_IN_LAST_X_DAYS
,
NOT_UPDATED_IN_LAST_X_DAYS
.
Copy code snippet
// datetime rolling property filter
{
"filterType": "PROPERTY",
"property": "datetime_property_name",
"operation": {
"propertyType": "rolling-property-updated",
"operator": "UPDATED_IN_LAST_X_DAYS",
"numberOfDays": 3
}
}
xxxxxxxxxx
10
1
// datetime rolling property filter
2
{
3
"filterType"
:
"PROPERTY"
,
4
"property"
:
"datetime_property_name"
,
5
"operation"
: {
6
"propertyType"
:
"rolling-property-updated"
,
7
"operator"
:
"UPDATED_IN_LAST_X_DAYS"
,
8
"numberOfDays"
:
3
9
}
10
}
Share your feedback
Was this article helpful?
Yes
No
This form is used for documentation feedback only. Learn how to
get help with HubSpot
Developer Home
HubSpot Developer Documentation home
Copyright © 2024 HubSpot, Inc.
Legal Stuff
Privacy Policy
Manage Cookies
Toggle menu
API Guides
Overview
Analytics and events
App management
Automation
CMS
Conversations
Library
CRM
Understanding the CRM
Using object APIs
Associations
Commerce
Engagements
Extensions
Export CRM data
Import CRM data
Lists
Overview
List filters
Objects
CRM embed
Owners
Pipelines
Properties
Search
Object Library
Marketing
Settings
Legal